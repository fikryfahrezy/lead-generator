import {
  getAllUnfinishLeads,
  LEAD_PROCESS_STATUS,
  MAX_UPDATE_RETRY,
  updateLead,
  type Lead,
  type LeadProcessStatus,
} from "@aksel/db";
import { CronJob } from "cron";
import * as dataForSeoClient from "dataforseo-client";

const CRONTAB = process.env.CRONTAB;
const DATA_FOR_SE_API_URL = process.env.DATA_FOR_SE_API_URL;
const DATA_FOR_SE_LOGIN = process.env.DATA_FOR_SE_LOGIN;
// Use English to be expected more international search
const LANGUAGE_CODE = "en";
// Use Indonesia for temporary, maybe it could changed to user input.
const LOCATION_NAME = "Indonesia";

// Maybe add proper validation instead of checking one-by-one like this.
// But for this simple use case, it's ok for now.
if (!CRONTAB || !DATA_FOR_SE_API_URL || !DATA_FOR_SE_LOGIN) {
  console.log(
    "env: CRONTAB, DATA_FOR_SE_API_URL and DATA_FOR_SE_LOGIN are required",
  );
  process.exit(1);
}

function createAuthenticatedFetch(token: string) {
  return (
    url: Parameters<typeof fetch>[0],
    init: Parameters<typeof fetch>[1],
  ): Promise<Response> => {
    const authHeader = { Authorization: `Basic ${token}` };

    const newInit: RequestInit = {
      ...init,
      headers: {
        ...init?.headers,
        ...authHeader,
      },
    };

    return fetch(url, newInit);
  };
}

/**
 * This is generated by LLM
 */
function isValidDomain(domain: string) {
  const regex = /^(?!-)[A-Za-z0-9-]{1,63}(?<!-)(\.[A-Za-z]{2,})+$/;
  return regex.test(domain);
}

function cleanDomain(input: string) {
  return input
    .replace(/^https?:\/\//, "") // remove http(s)
    .replace(/^www\./, ""); // remove www
}

/**
 * This is generated by LLM
 */
function extractEmails(text: string) {
  const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
  return text.match(emailRegex) || [];
}

type SeoAPIParams = {
  seoAPI: string;
  seoToken: string;
};

type GetSearchEmailParams = SeoAPIParams & {
  keyword: string;
};

async function getSearchEmail({
  seoAPI,
  seoToken,
  keyword,
}: GetSearchEmailParams) {
  const authFetch = createAuthenticatedFetch(seoToken);
  const serpApi = new dataForSeoClient.SerpApi(seoAPI, {
    fetch: authFetch,
  });

  const task = new dataForSeoClient.SerpGoogleOrganicLiveAdvancedRequestInfo({
    language_code: LANGUAGE_CODE,
    location_name: LOCATION_NAME,
    keyword: keyword,
  });

  const resp = await serpApi.googleOrganicLiveAdvanced([task]);
  if (!resp) {
    return undefined;
  }

  const firstResult = resp.tasks?.[0]?.result?.[0];
  const emails = firstResult?.items?.flatMap((item) => {
    const highlight = (item["highlighted"] ?? []).join(" ");
    const emailInHighlight = extractEmails(highlight);
    const description = item.description ?? "";
    const emailInDescription = extractEmails(description);
    return [...emailInDescription, ...emailInHighlight];
  });
  return emails;
}

type GetMapParams = SeoAPIParams & {
  keyword: string;
};

async function getMap({ seoAPI, seoToken, keyword }: GetMapParams) {
  const authFetch = createAuthenticatedFetch(seoToken);
  const serpApi = new dataForSeoClient.SerpApi(seoAPI, {
    fetch: authFetch,
  });

  const task = new dataForSeoClient.SerpGoogleMapsLiveAdvancedRequestInfo({
    language_code: LANGUAGE_CODE,
    location_name: LOCATION_NAME,
    keyword: keyword,
  });

  const resp = await serpApi.googleMapsLiveAdvanced([task]);
  if (!resp) {
    return undefined;
  }

  const firstResult = resp.tasks?.[0]?.result?.[0];
  const highestRank = firstResult?.items?.[0];
  return highestRank;
}

type GetDomainParams = SeoAPIParams & {
  keyword: string;
};

async function getDomain({
  seoAPI,
  seoToken,
  keyword,
}: GetDomainParams): Promise<string | undefined> {
  const authFetch = createAuthenticatedFetch(seoToken);
  const serpApi = new dataForSeoClient.SerpApi(seoAPI, {
    fetch: authFetch,
  });

  const task = new dataForSeoClient.SerpGoogleOrganicLiveAdvancedRequestInfo({
    keyword,
    language_code: LANGUAGE_CODE,
    location_name: LOCATION_NAME,
  });

  const resp = await serpApi.googleOrganicLiveAdvanced([task]);
  if (!resp) {
    return undefined;
  }

  const firstResult = resp.tasks?.[0]?.result?.[0];
  const highestRank = firstResult?.items?.[0];
  return highestRank?.["domain"];
}

type EnrichLeadDataParams = SeoAPIParams & {
  lead: Lead;
};

async function enrichLeadData({
  lead,
  seoAPI,
  seoToken,
}: EnrichLeadDataParams) {
  // Use domain to find email address
  let domain = lead.keyword;
  // If the keyword is not a domain then, we need to find it first
  if (!isValidDomain(domain)) {
    const domainFromKeyword = await getDomain({
      seoAPI,
      seoToken,
      keyword: lead.keyword,
    });

    if (domainFromKeyword) {
      domain = `${cleanDomain(domainFromKeyword)}`;
    }
  }

  const leadLocationResult = await getMap({
    seoAPI,
    seoToken,
    keyword: lead.keyword,
  });

  const leadPotentialEmails = await getSearchEmail({
    seoAPI,
    seoToken,
    keyword: `contact email @${domain}`,
  });

  const leadPotentialEmail = leadPotentialEmails?.[0];
  const leadAddress = leadLocationResult?.["address"];
  const leadPhone = leadLocationResult?.["phone"];

  let status: LeadProcessStatus = LEAD_PROCESS_STATUS.FAILED;
  let note: string = "";
  const requiredFields = [
    { value: leadPotentialEmail, message: "email not found" },
    { value: leadAddress, message: "address not found" },
    { value: leadPhone, message: "phone not found" },
  ];

  const emptyValues = requiredFields
    .filter((requiredField) => {
      return !!requiredField.value;
    })
    .map((requiredField) => {
      return requiredField.message;
    });

  if (emptyValues.length === 0) {
    status = LEAD_PROCESS_STATUS.SUCCESS;
  } else if (emptyValues.length <= requiredFields.length) {
    status = LEAD_PROCESS_STATUS.PENDING;
  } else {
    status = LEAD_PROCESS_STATUS.FAILED;
    note = emptyValues.join(", ");
  }

  const newRetry = lead.retry + 1;
  const shouldFailed =
    newRetry === MAX_UPDATE_RETRY && status !== LEAD_PROCESS_STATUS.SUCCESS;
  const newStatus = shouldFailed ? LEAD_PROCESS_STATUS.FAILED : status;

  await updateLead({
    ...lead,
    note,
    email: leadPotentialEmail || lead.email,
    address: leadAddress || lead.address,
    phone: leadPhone || lead.phone,
    status: newStatus,
    retry: newRetry,
  });

  return lead.keyword;
}

async function runProcess(params: SeoAPIParams) {
  const allLeads = await getAllUnfinishLeads();

  if (!allLeads.success) {
    console.log("Unable to get leads data");
    return;
  }

  const allSettled = await Promise.allSettled(
    allLeads.data.map((lead) => {
      return enrichLeadData({ ...params, lead });
    }),
  );
  console.log(allSettled);
}

new CronJob(
  CRONTAB, // cronTime
  () => {
    runProcess({ seoAPI: DATA_FOR_SE_API_URL, seoToken: DATA_FOR_SE_LOGIN });
  }, // onTick
  null, // onComplete
  true, // start
  "Asia/Jakarta", // timeZone
);
