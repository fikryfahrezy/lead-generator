import {
  getAllUnfinishLeads,
  LEAD_PROCESS_STATUS,
  updateLead,
  type Lead,
  type LeadProcessStatus,
} from "@aksel/db";
import * as dataForSeoClient from "dataforseo-client";

const CRONTAB = process.env.CRONTAB;
const DATA_FOR_SE_API_URL = process.env.DATA_FOR_SE_API_URL;
const DATA_FOR_SE_LOGIN = process.env.DATA_FOR_SE_LOGIN;
// Use English to be expected more international search
const LANGUAGE_CODE = "en";
// Use US to have (maybe) less restriction
const LOCATION_NAME = "Indonesia";

// Maybe add proper validation instead of checking one-by-one like this.
// But for this simple use case, it's ok for now.
if (!CRONTAB || !DATA_FOR_SE_API_URL || !DATA_FOR_SE_LOGIN) {
  console.log(
    "env: CRONTAB, DATA_FOR_SE_API_URL and DATA_FOR_SE_LOGIN are required",
  );
  process.exit(1);
}

function createAuthenticatedFetch(token: string) {
  return (
    url: Parameters<typeof fetch>[0],
    init: Parameters<typeof fetch>[1],
  ): Promise<Response> => {
    const authHeader = { Authorization: `Basic ${token}` };

    const newInit: RequestInit = {
      ...init,
      headers: {
        ...init?.headers,
        ...authHeader,
      },
    };

    return fetch(url, newInit);
  };
}

/**
 * This is generated by LLM
 */
function isValidDomain(domain: string) {
  const regex = /^(?!-)[A-Za-z0-9-]{1,63}(?<!-)(\.[A-Za-z]{2,})+$/;
  return regex.test(domain);
}

// function cleanDomain(input: string) {
//   return input
//     .replace(/^https?:\/\//, "") // remove http(s)
//     .replace(/^www\./, ""); // remove www
// }

type SeoAPIParams = {
  seoAPI: string;
  seoToken: string;
};

// type GetSearchParams = SeoAPIParams & {
//   keyword: string;
// };

// async function getSearch({ seoAPI, seoToken, keyword }: GetSearchParams) {
//   const authFetch = createAuthenticatedFetch(seoToken);
//   const serpApi = new dataForSeoClient.SerpApi(seoAPI, {
//     fetch: authFetch,
//   });

//   const task = new dataForSeoClient.SerpGoogleOrganicLiveAdvancedRequestInfo({
//     language_code: LANGUAGE_CODE,
//     location_name: LOCATION_NAME,
//     keyword: keyword,
//   });

//   const resp = await serpApi.googleOrganicLiveAdvanced([task]);
//   if (!resp) {
//     return undefined;
//   }

//   const firstResult = resp.tasks?.[0]?.result?.[0];
//   const highestRank = firstResult?.items?.[0];
//   return highestRank;
// }

type GetMapParams = SeoAPIParams & {
  keyword: string;
};

async function getMap({ seoAPI, seoToken, keyword }: GetMapParams) {
  const authFetch = createAuthenticatedFetch(seoToken);
  const serpApi = new dataForSeoClient.SerpApi(seoAPI, {
    fetch: authFetch,
  });

  const task = new dataForSeoClient.SerpGoogleMapsLiveAdvancedRequestInfo({
    language_code: LANGUAGE_CODE,
    location_name: LOCATION_NAME,
    keyword: keyword,
  });

  const resp = await serpApi.googleMapsLiveAdvanced([task]);
  if (!resp) {
    return undefined;
  }

  const firstResult = resp.tasks?.[0]?.result?.[0];
  const highestRank = firstResult?.items?.[0];
  return highestRank;
}

// type GetBussinessInfoParams = SeoAPIParams & {
//   keyword: string;
// };

// async function getBussinessInfo({
//   seoAPI,
//   seoToken,
//   keyword,
// }: GetBussinessInfoParams) {
//   const authFetch = createAuthenticatedFetch(seoToken);

//   const task =
//     new dataForSeoClient.BusinessDataGoogleMyBusinessInfoLiveRequestInfo({
//       language_code: LANGUAGE_CODE,
//       location_name: LOCATION_NAME,
//       keyword: keyword,
//     });

//   const businessDataApi = new dataForSeoClient.BusinessDataApi(seoAPI, {
//     fetch: authFetch,
//   });
//   const resp = await businessDataApi.googleMyBusinessInfoLive([task]);
//   if (!resp) {
//     return undefined;
//   }

//   const firstResult = resp.tasks?.[0]?.result?.[0];
//   const highestRank = firstResult?.items?.[0];
//   return highestRank;
// }

// type GetDomainParams = SeoAPIParams & {
//   keyword: string;
// };

// async function getDomain({
//   seoAPI,
//   seoToken,
//   keyword,
// }: GetDomainParams): Promise<string | undefined> {
//   const authFetch = createAuthenticatedFetch(seoToken);
//   const serpApi = new dataForSeoClient.SerpApi(seoAPI, {
//     fetch: authFetch,
//   });

//   const task = new dataForSeoClient.SerpGoogleOrganicLiveAdvancedRequestInfo({
//     keyword,
//     language_code: LANGUAGE_CODE,
//     location_name: LOCATION_NAME,
//   });

//   const resp = await serpApi.googleOrganicLiveAdvanced([task]);
//   if (!resp) {
//     return undefined;
//   }

//   const firstResult = resp.tasks?.[0]?.result?.[0];
//   const highestRank = firstResult?.items?.[0];
//   return highestRank?.["domain"];
// }

// type ValidateDomainParams = SeoAPIParams & {
//   keyword: string;
// };

// async function validateDomain({
//   seoAPI,
//   seoToken,
//   keyword,
// }: ValidateDomainParams): Promise<string | undefined> {
//   const authFetch = createAuthenticatedFetch(seoToken);

//   const task =
//     new dataForSeoClient.DomainAnalyticsTechnologiesDomainTechnologiesLiveRequestInfo(
//       {
//         target: keyword,
//       },
//     );

//   const domainAnalyticsApi = new dataForSeoClient.DomainAnalyticsApi(seoAPI, {
//     fetch: authFetch,
//   });
//   const resp = await domainAnalyticsApi.technologiesDomainTechnologiesLive([
//     task,
//   ]);
//   if (!resp) {
//     return undefined;
//   }

//   const firstResult = resp.tasks?.[0]?.result?.[0];
//   return firstResult?.domain;
// }

type EnrichLeadDataParams = SeoAPIParams & {
  lead: Lead;
};

async function enrichLeadData({
  lead,
  seoAPI,
  seoToken,
}: EnrichLeadDataParams) {
  // Search using domain to increase accuracy
  const keyword = lead.keyword;
  // If the keyword no domain then, we need to validate it first
  if (!isValidDomain(keyword)) {
    // const domainFromKeyword = await getDomain({
    //   seoAPI,
    //   seoToken,
    //   keyword: keyword,
    // });
    // if (domainFromKeyword) {
    //   keyword += ` ${cleanDomain(domainFromKeyword)}`;
    // }
  }

  // const validDomain = await validateDomain({
  //   seoAPI,
  //   seoToken,
  //   keyword: domain,
  // });
  // if (!validDomain) {
  //   console.log("Failed to validate the domain: ", domain);
  //   return await updateLead({
  //     ...lead,
  //     status: LEAD_PROCESS_STATUS.FAILED,
  //   });
  // }

  const leadLocationResult = await getMap({
    seoAPI,
    seoToken,
    keyword: keyword,
  });

  const leadAddress = leadLocationResult?.["address"];
  const leadPhone = leadLocationResult?.["phone"];

  // const leadSearchResult = await getSearch({
  //   seoAPI,
  //   seoToken,
  //   keyword: `${lead.keyword} contract email`,
  // });

  // if (!leadSearchResult) {
  //   console.log("Failed to get email: ", keyword);
  //   return await updateLead({
  //     ...lead,
  //     status: LEAD_PROCESS_STATUS.FAILED,
  //   });
  // }

  let status: LeadProcessStatus = LEAD_PROCESS_STATUS.FAILED;
  const requiredFields = [leadAddress, leadPhone];

  const isAllDefined = requiredFields.every((requiredField) => {
    return requiredField !== undefined;
  });
  if (isAllDefined) {
    status = LEAD_PROCESS_STATUS.SUCCESS;
  }

  const isSomeDefined = requiredFields.some((requiredField) => {
    return requiredField !== undefined;
  });
  if (isSomeDefined) {
    status = LEAD_PROCESS_STATUS.PENDING;
  }

  const isAllUndefined = requiredFields.every((requiredField) => {
    return requiredField === undefined;
  });
  if (isAllUndefined) {
    status = LEAD_PROCESS_STATUS.FAILED;
  }

  await updateLead({
    ...lead,
    address: leadAddress,
    phone: leadPhone,
    status: status,
  });
}

async function runProcess(params: SeoAPIParams) {
  const allLeads = await getAllUnfinishLeads();

  if (!allLeads.success) {
    console.log("Unable to get leads data");
    return;
  }

  await Promise.allSettled(
    allLeads.data.map((lead) => {
      return enrichLeadData({ ...params, lead });
    }),
  );
}

await runProcess({ seoAPI: DATA_FOR_SE_API_URL, seoToken: DATA_FOR_SE_LOGIN });

// new CronJob(
//   CRONTAB, // cronTime
//   () => {
//     runProcess({ seoAPI: DATA_FOR_SE_API_URL, seoToken: DATA_FOR_SE_LOGIN });
//   }, // onTick
//   null, // onComplete
//   true, // start
//   "Asia/Jakarta", // timeZone
// );
